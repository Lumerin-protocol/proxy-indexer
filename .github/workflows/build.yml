name: Deploy Spot Indexer

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment (dev=DEV, stg=STG, main=LMN/PROD)'
        required: false
        type: choice
        options:
          - dev
          - stg
          - main
      build_only:
        description: 'Build and push only (skip deployment)'
        required: false
        type: boolean
        default: false

  # Full pipeline on push to main branches
  push:
    branches:
      - main
      - stg
      - dev
    paths: [".github/**", "src/**", "Dockerfile", "package.json", "package-lock.json", "LICENSE", "README.md"]

  # Build test only on PRs targeting dev
  pull_request:
    branches:
      - dev
    types: [opened, reopened, synchronize]
    paths: [".github/**", "src/**", "Dockerfile", "package.json", "package-lock.json", "LICENSE", "README.md"]

concurrency:
  group: ci-${{ github.ref }}
  cancel-in-progress: true

defaults:
  run:
    shell: bash

permissions:
  id-token: write   # Required for OIDC
  contents: write   # Required for creating tags
  packages: write   # For GHCR

env:
  SERVICE_NAME: spot-indexer
  GHCR_REGISTRY: ghcr.io
  GHCR_IMAGE: ghcr.io/lumerin-protocol/proxy-indexer

jobs:
  generate-tag:
    runs-on: ubuntu-latest
    name: ðŸ“¦ Generate Tag
    outputs:
      tag_name: ${{ steps.gen_tag_name.outputs.tag_name }}
      vtag: ${{ steps.gen_tag_name.outputs.vtag }}
      vfull: ${{ steps.gen_tag_name.outputs.vfull }}
      environment: ${{ steps.determine_env.outputs.environment }}
      should_deploy: ${{ steps.determine_env.outputs.should_deploy }}
      ecs_cluster: ${{ steps.determine_env.outputs.ecs_cluster }}
      ecs_service: ${{ steps.determine_env.outputs.ecs_service }}
      aws_region: ${{ steps.determine_env.outputs.aws_region }}
    steps:
      - name: Clone repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Determine environment
        id: determine_env
        run: |
          # Determine environment based on branch or manual input
          if [ "${{ github.event_name }}" == "workflow_dispatch" ] && [ -n "${{ github.event.inputs.environment }}" ]; then
            ENV="${{ github.event.inputs.environment }}"
          else
            BRANCH="${{ github.ref_name }}"
            case "$BRANCH" in
              main) ENV="main" ;;
              stg)  ENV="stg" ;;
              *)    ENV="dev" ;;
            esac
          fi
          echo "environment=${ENV}" >> $GITHUB_OUTPUT
          
          # Determine if we should deploy (not a PR, not build_only)
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            echo "should_deploy=false" >> $GITHUB_OUTPUT
          elif [ "${{ github.event.inputs.build_only }}" == "true" ]; then
            echo "should_deploy=false" >> $GITHUB_OUTPUT
          else
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          fi
          
          # Set ECS cluster and service names based on environment
          case $ENV in
            dev)
              echo "aws_region=us-east-1" >> $GITHUB_OUTPUT
              echo "ecs_cluster=ecs-lumerin-marketplace-dev-use1" >> $GITHUB_OUTPUT
              echo "ecs_service=svc-lumerin-indexer-dev-use1" >> $GITHUB_OUTPUT
              ;;
            stg)
              echo "aws_region=us-east-1" >> $GITHUB_OUTPUT
              echo "ecs_cluster=ecs-lumerin-marketplace-stg-use1" >> $GITHUB_OUTPUT
              echo "ecs_service=svc-lumerin-indexer-stg-use1" >> $GITHUB_OUTPUT
              ;;
            main)
              echo "aws_region=us-east-1" >> $GITHUB_OUTPUT
              echo "ecs_cluster=ecs-lumerin-marketplace-lmn-use1" >> $GITHUB_OUTPUT
              echo "ecs_service=svc-lumerin-indexer-lmn-use1" >> $GITHUB_OUTPUT
              ;;
          esac

      - name: Determine tag name
        id: gen_tag_name
        shell: bash
        run: |
          VMAJ_NEW=2
          VMIN_NEW=0
          VPAT_NEW=0
          set +o pipefail
          VLAST=$(git describe --tags --abbrev=0 --match='v[1-9]*' refs/remotes/origin/main 2>/dev/null | cut -c2-)

          if [ -n "$VLAST" ]; then
              eval $(echo "$VLAST" | awk -F '.' '{print "VMAJ="$1" VMIN="$2" VPAT="$3}')
          else
              VMAJ=0
              VMIN=0
              VPAT=0
          fi

          ENV="${{ steps.determine_env.outputs.environment }}"
          
          if [ "$GITHUB_REF_NAME" = "main" ] || [ "$ENV" = "main" ]; then
              if [ "$VMAJ_NEW" -gt "$VMAJ" ]; then
                  VMAJ=$VMAJ_NEW
                  VMIN=$VMIN_NEW
                  VPAT=$VPAT_NEW
              else
                  VMIN=$((VMIN+1))
                  VPAT=0
              fi
              VFULL=${VMAJ}.${VMIN}.${VPAT}
              VTAG=v$VFULL
          else
              MB=$(git merge-base refs/remotes/origin/main HEAD)
              VPAT=$(git rev-list --count --no-merges ${MB}..HEAD)
              VFULL=${VMAJ}.${VMIN}.${VPAT}
              VTAG=v${VFULL}-${ENV}
          fi

          # Output variables for use in subsequent jobs
          echo "tag_name=${VTAG}" >> $GITHUB_OUTPUT
          echo "vtag=${VTAG}" >> $GITHUB_OUTPUT
          echo "vfull=${VFULL}" >> $GITHUB_OUTPUT
          echo "âœ… Build Tag: $VTAG" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ“¦ Docker Image: ${{ env.GHCR_IMAGE }}:${VTAG}" >> $GITHUB_STEP_SUMMARY
          echo "ðŸŒ Environment: ${ENV}" >> $GITHUB_STEP_SUMMARY

  test-build:
    name: ðŸ§ª Test Build
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    needs: generate-tag
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Build Docker Image (test only)
        run: |
          BUILDTAG=${{ needs.generate-tag.outputs.tag_name }}
          BUILDCOMMIT=${{ github.sha }}
          docker build \
            --platform linux/amd64 \
            --build-arg TAG_NAME=$BUILDTAG \
            --build-arg COMMIT=$BUILDCOMMIT \
            -t ${{ env.GHCR_IMAGE }}:$BUILDTAG \
            -f ./Dockerfile \
            . || (echo "âŒ Failed to build image" && exit 1)
          echo "âœ… Test build successful!"

  build-and-push:
    name: ðŸ”¨ Build & Push
    if: github.event_name != 'pull_request'
    runs-on: ubuntu-latest
    needs: generate-tag
    outputs:
      version: ${{ needs.generate-tag.outputs.tag_name }}
      environment: ${{ needs.generate-tag.outputs.environment }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.GHCR_REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Inject version into package.json
        run: |
          FULLTAG=${{ needs.generate-tag.outputs.vfull }}
          echo "Injecting version $FULLTAG into package.json"
          sed -i "s/\"version\": \".*\"/\"version\": \"$FULLTAG\"/" ./package.json
          cat ./package.json | grep '"version"'

      - name: Build and Push Docker Image
        run: |
          BUILDTAG=${{ needs.generate-tag.outputs.tag_name }}
          BUILDCOMMIT=${{ github.sha }}
          ENV=${{ needs.generate-tag.outputs.environment }}
          
          docker build \
            --platform linux/amd64 \
            --build-arg TAG_NAME=$BUILDTAG \
            --build-arg COMMIT=$BUILDCOMMIT \
            --push \
            -t ${{ env.GHCR_IMAGE }}:$BUILDTAG \
            -f ./Dockerfile \
            . || (echo "âŒ Failed to push image" && exit 1)
          
          echo "âœ… Pushed ${{ env.GHCR_IMAGE }}:$BUILDTAG"

      - name: Push environment-latest tag (dev/stg only)
        if: needs.generate-tag.outputs.environment != 'main'
        run: |
          BUILDTAG=${{ needs.generate-tag.outputs.tag_name }}
          ENV=${{ needs.generate-tag.outputs.environment }}
          
          docker pull ${{ env.GHCR_IMAGE }}:$BUILDTAG
          docker tag ${{ env.GHCR_IMAGE }}:$BUILDTAG ${{ env.GHCR_IMAGE }}:latest-${ENV}
          docker push ${{ env.GHCR_IMAGE }}:latest-${ENV}
          
          echo "âœ… Pushed ${{ env.GHCR_IMAGE }}:latest-${ENV}"

      - name: Push latest tag (main only)
        if: needs.generate-tag.outputs.environment == 'main'
        run: |
          BUILDTAG=${{ needs.generate-tag.outputs.tag_name }}
          docker pull ${{ env.GHCR_IMAGE }}:$BUILDTAG
          docker tag ${{ env.GHCR_IMAGE }}:$BUILDTAG ${{ env.GHCR_IMAGE }}:latest
          docker push ${{ env.GHCR_IMAGE }}:latest
          echo "âœ… Pushed ${{ env.GHCR_IMAGE }}:latest"

      # Create git tag immediately after successful GHCR push
      # This enables Terraform auto-lookup to find the latest version
      - name: Configure Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Create and push git tag
        run: |
          TAG_NAME=${{ needs.generate-tag.outputs.tag_name }}
          echo "ðŸ·ï¸ Creating git tag: $TAG_NAME"
          
          if git rev-parse "$TAG_NAME" >/dev/null 2>&1; then
            echo "âš ï¸ Tag $TAG_NAME already exists, skipping"
          else
            git tag -a "$TAG_NAME" -m "Release $TAG_NAME - Container pushed to GHCR"
            git push origin "$TAG_NAME"
            echo "âœ… Git tag $TAG_NAME created and pushed"
          fi

      - name: Build summary
        run: |
          echo "## ðŸ“¦ Build Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Container Tags:**" >> $GITHUB_STEP_SUMMARY
          echo "- \`${{ env.GHCR_IMAGE }}:${{ needs.generate-tag.outputs.tag_name }}\` (semver)" >> $GITHUB_STEP_SUMMARY
          if [ "${{ needs.generate-tag.outputs.environment }}" == "main" ]; then
            echo "- \`${{ env.GHCR_IMAGE }}:latest\`" >> $GITHUB_STEP_SUMMARY
          else
            echo "- \`${{ env.GHCR_IMAGE }}:latest-${{ needs.generate-tag.outputs.environment }}\`" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Git Tag:** \`${{ needs.generate-tag.outputs.tag_name }}\`" >> $GITHUB_STEP_SUMMARY

  deploy:
    name: ðŸš€ Deploy
    if: needs.generate-tag.outputs.should_deploy == 'true'
    runs-on: ubuntu-latest
    needs: [generate-tag, build-and-push]
    
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ needs.generate-tag.outputs.environment == 'dev' && secrets.AWS_ROLE_ARN_DEV || needs.generate-tag.outputs.environment == 'stg' && secrets.AWS_ROLE_ARN_STG || secrets.AWS_ROLE_ARN_LMN }}
          aws-region: ${{ needs.generate-tag.outputs.aws_region }}
          role-session-name: GitHubActions-SpotIndexer-${{ github.run_id }}

      - name: Update ECS service
        run: |
          echo "ðŸš€ Deploying to ${{ needs.generate-tag.outputs.environment }} environment"
          echo "   Cluster: ${{ needs.generate-tag.outputs.ecs_cluster }}"
          echo "   Service: ${{ needs.generate-tag.outputs.ecs_service }}"
          echo "   Image: ${{ env.GHCR_IMAGE }}:${{ needs.generate-tag.outputs.tag_name }}"
          
          aws ecs update-service \
            --cluster ${{ needs.generate-tag.outputs.ecs_cluster }} \
            --service ${{ needs.generate-tag.outputs.ecs_service }} \
            --force-new-deployment \
            --region ${{ needs.generate-tag.outputs.aws_region }}
          
          echo "âœ… Deployment triggered"

  verify:
    name: ðŸ” Verify
    if: needs.generate-tag.outputs.should_deploy == 'true'
    runs-on: ubuntu-latest
    needs: [generate-tag, deploy]
    
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ needs.generate-tag.outputs.environment == 'dev' && secrets.AWS_ROLE_ARN_DEV || needs.generate-tag.outputs.environment == 'stg' && secrets.AWS_ROLE_ARN_STG || secrets.AWS_ROLE_ARN_LMN }}
          aws-region: ${{ needs.generate-tag.outputs.aws_region }}
          role-session-name: GitHubActions-SpotIndexer-Verify-${{ github.run_id }}

      - name: Wait for service to stabilize
        run: |
          echo "â³ Waiting for service to stabilize..."
          aws ecs wait services-stable \
            --cluster ${{ needs.generate-tag.outputs.ecs_cluster }} \
            --services ${{ needs.generate-tag.outputs.ecs_service }} \
            --region ${{ needs.generate-tag.outputs.aws_region }}
          
          echo "âœ… Service is stable"

  summary:
    name: ðŸ“Š Summary
    runs-on: ubuntu-latest
    needs: [generate-tag, build-and-push, deploy, verify]
    if: always() && needs.generate-tag.outputs.should_deploy == 'true'
    
    steps:
      - name: Deployment summary
        if: needs.verify.result == 'success'
        run: |
          echo "## ðŸŽ‰ Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Service:** Spot Indexer" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** ${{ needs.generate-tag.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ needs.generate-tag.outputs.tag_name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Container Tags:**" >> $GITHUB_STEP_SUMMARY
          echo "- \`${{ env.GHCR_IMAGE }}:${{ needs.generate-tag.outputs.tag_name }}\`" >> $GITHUB_STEP_SUMMARY
          if [ "${{ needs.generate-tag.outputs.environment }}" == "main" ]; then
            echo "- \`${{ env.GHCR_IMAGE }}:latest\`" >> $GITHUB_STEP_SUMMARY
          else
            echo "- \`${{ env.GHCR_IMAGE }}:latest-${{ needs.generate-tag.outputs.environment }}\`" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**ECS:**" >> $GITHUB_STEP_SUMMARY
          echo "- Cluster: \`${{ needs.generate-tag.outputs.ecs_cluster }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- Service: \`${{ needs.generate-tag.outputs.ecs_service }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âœ… Service deployed and stabilized successfully" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ·ï¸ Git tag \`${{ needs.generate-tag.outputs.tag_name }}\` created" >> $GITHUB_STEP_SUMMARY

      - name: Failure summary
        if: needs.verify.result == 'failure'
        run: |
          echo "## âŒ Deployment Failed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Service:** Spot Indexer" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** ${{ needs.generate-tag.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ needs.generate-tag.outputs.tag_name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âš ï¸ Deployment or verification failed. Check logs above for details." >> $GITHUB_STEP_SUMMARY
          echo "ðŸ“¦ Note: Container was pushed and git tag was created before deployment failed." >> $GITHUB_STEP_SUMMARY
